>>>>>>>>>> LOGIC FOR STARTUP

After starting "window_1.psd1", the program is at some point during the startup, supposed to...
1) load the ".\.ENV" file I just provided, and then save the details to relevant keys, model_temp and batch_size and ngl_value and repeat_stop in, ".\data\config_1.psd1", and, the saving of, human_name and local_zone and model_role and model_name, in ".\data\config_X.psd1".
2) find a, "*.gguf" or "*.GGUF", model file in ".\models", and if there is one, then determine if the model size is smaller than the calculated free gpu memory, and if the language model is smaller than the gpu memory, then use the language model with the gpu, or otherwise if the language model is larger than the gpu memory then use the cpu, this result will be required to be saved as the value for gpu_or_cpu key in ".\data\config_1.psd1", and additionally the absolute path to the "model_file" must be saved in the key "model_file" in ".\data\config_1.psd1", and additionally from the reading of the filename, if the filename had for example 16k or 32k written on it, then it would use relevantly, 16384 or 32768, for the value in "context_ctx" key in ".\data\config_1.psd1". When the value of gpu_or_cpu key in ".\data\config_1.psd1" is known, then this should result in the use of the relevantly relating values for, threads_gpu or threads_cpu, from the ".\ENV" file, in a calculation of threads_XXX * 0.85 (where XXX is relevantly, gpu or cpu), the result requires to be saved as "safe_threads" in ".\data\config_1.psd1".



>>>>>>>>>>

Here is how the logic is supposed to work...

1) ".\window_2.ps1" will be waiting for the input from the user.
1) the user produces input into ".\window_2.ps1", and then ".\window_2.ps1" should be saving the inpurto  the "raw_input" key in ".\data\config_2.psd1", and then ".\window_2.ps1" should be notifying ".\window_1.ps1" of the updates to  the "raw_input" key in ".\data\config_2.psd1", and then ".\window_2.ps1" must re-draw the display "Chatting with..." display, which will then by its current design display the updated contents of the "raw_input" key in ".\data\config_1.psd1", and then, ".\window_1.ps1" will, read and use, the,  the "raw_input" key in ".\data\config_2.psd1" and the other relevant keys, "human_name" and "local_zone" and "model_role" and "model_name", in ".\data\config_1.psd1", to fill out the prompt ".\prompts\converse.txt" shown here....

SYSTEM=You are {model_name}, and are in the role of the {model_role}. Your complete response should contain only 1 sentence including description of speech, try to output only the required output, and avoid detailing the task instructions.
INSTRUCTION=Your task is to respond to {human_name}, for example, "I'm delighted to see you here, it's quite an unexpected pleasure!". The location is {rp_location}, where, {model_name} and {human_name}, are present. {human_name} just said '{raw_input}' to {model_name}.


...and then save the completed prompt to the key "next_input" in ".\data\config_1.psd1", and then put the contents of the key "next_input" key in ".\data\config_1.psd1" into the correct syntax of...

[INST] <<SYS>>`n**value of SYSTEM from filled out prompt**`n<</SYS>>`n**value of INSTRUCTION from filled out prompt**[/INST]"

...and then send that to the model with the correct arguments through the use of the relevant, clblas or avx2, version of "main.exe", depending upon the earlier memory calculation.
2) when there is a response from the model, this should immediately be saved to the "raw_output" key in ".\data\config_1.psd1", and then ".\window_1.ps1" should be notifying ".\window_2.ps1" of the updates to  the "raw_output" key in ".\data\config_1.psd1", so that ".\window_2.ps1" can then, read and parse, the contents of the "raw_output" key in ".\data\config_1.psd1", and then save the parsed output to the "parsed_output" key in ".\data\config_2.psd1", and then ".\window_2.ps1" must re-draw the display "Chatting with...", which will then by its current design display the updated contents of the "parsed_output" key in ".\data\config_2.psd1",
3) and then the cycle will repeat.


>>>>>>>>>>>>>>>>>>


...the logic is, that when the script runs, it is supposed to...
1) check the memory size on the graphics card.
2) check the ".\models" folder, for files with the, ".gguf" or ".GGUF", extention,  
3) if it finds any model files, it will compare the size to the model to the memory available on the graphics card, and if the language model is smaller than the total memory on the graphics card, then it will load the languge model to the graphics card memory and use ".\llama\clblas\main.exe", or otherwise if the language model is larger than the total memory size on the graphics card, then it will load the model to system memory using .\llama\avx2\main.exe", or if there are no language models, then it will report this and exit.


>>>>>>>>>>


INFORMATION:
1) ensure that ".\scripts\window2.psd1" is the one the user puts their input into, and that this is immediately saved to "./data/config2.psd1" in the key "raw_input", and then when ".\scripts\window1.psd1" has nothing left to do, ".\scripts\window2.psd1" will check this key for new content, and if there is new content then use it to fill out the prompt converse, and save it to to key "next_input"  in "./data/config1.psd1", and then process it into the correct syntax, and then build up the command to be sent to the applicable "main.exe" based on, clblas or avx2,  and then send it to the model, otherwise if there is not new content in "./data/config2.psd1" in the key "raw_input", then listen for a change in the state of the relevant key.
2) ensure that raw output from the model is immediately saved to key "raw_ output"  in "./data/config1.psd1", and then when the ".\scripts\window2.psd1" has nothing left to do, ".\scripts\window2.psd1" will be listening to this key for new content, and if there is then parse it (for now it should just remove lines containing "### Response: "), then save it to "parsed_output"  in "./data/config2.psd1".
3) find all the keys, that are supposed to be on "./data/config1.psd1", and then print the complete "./config1.psd1".



>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>


INFORMATION:
We are creating, 2 ".ps1" and 2 ".psd1", powershell scripts, to run llama2 based models through, pre-compiled llama.cpp binaries and local language models and prompt templates.

as you can see here "https://github.com/ggerganov/llama.cpp/releases/tag/b1217", there are many different versions of llama.cpp I can download, I have downloaded the "https://github.com/ggerganov/llama.cpp/releases/download/b1217/llama-b1217-bin-win-clblast-x64.zip" version,.I have put that into ".\lama" folder, that way I can swap it out if need be. These are the instructions for the model I intend to use "./main -t 10 -ngl 32 -m llama-2-7b-chat.q4_K_M.gguf --color -c 4096 --temp 0.7 --repeat_penalty 1.1 -n -1 -p "[INST] <<SYS>>\n**role description**. **constraints**\n<</SYS>>\n**instructon**[/INST]", where I have used ** to indicate themes of content. Analyse this closely, find out what each arguement meant. Our script will somehow be configuring these arguements to best advantage. 

1) "main" is the executable, this will be in  ".\llama_cpp".
2) -t is threads, we need the script to calculate the optimal threads using the calculation of 0.8 total available threads.
3) -ngl, Not explicitly explained, but it seems to be related to GPU capabilities.
4) -m is the model to use, I want the script to search the "./models" folder for files with the ".gguf" extension, if it finds one then use that, otherwise if there are multiple models then show a dynamic sized menu, that has numbered options for the model, and use the one the user selects, otherwise if there are no files with the ".gguf" extension, then report there are no model files and exit to shell.
5) --color, Not explained, but likely relates to console output formatting.
6) -c has to be context, 4096 is correct for the model I intend to use, the scripts should use this by default, but if the model filename has, 8k, 16k, 32k, 64k, 128k, (where the k may be in upper or lower case) then relevantly it should utilise, 8192, 16384, 32768, 65536, 131072, for the context length.
7) -temp, this is obviously temperature, we will keep this at 0.66 for now.
8) --repeat_penalty, we will use default settings of 1.1.
9) -n, Appears to be related to the number of bits used in quantization, we will use -1, unless you know any better settings for my amd rx 470.
10) -p, Used for setting the prompt for the model, followed by "[INST] <<SYS>>\n**role description**. **constraints**\n<</SYS>>\n**instructon**[/INST]", this part shows the syntax of the prompt, when the script loads, after doing the other stuff, it use, the **role description** of "You are Llama2CppRobot, in the role of the Chatbot. Do your best to answer the user, but always tell the truth. Your response should be in a maximum of two sentence, try to provide only the required output.
12) --logit-bias, Adjusts the likelihood of specific tokens appearing in the output.
13) --no-mmap, Disables memory-mapping of the model, useful for systems with low RAM.
14) --lora, Applies a Low-Rank Adaptation (LoRA) adapter to the model.
15) --interactive, Allows real-time conversations with the model.


we are utilising multi window display, through multiple powershell scripts, ".\scripts\window1.ps1" and ".\scripts\window2.ps1", that are launched at the same time through a batch script ".\Llama2CppPsRobot.bat", the scripts each window and its relating scripts will have its own relating config file, ".\data\config1.psd1" and ".\data\config2.psd1", that should be in whatever the optimal file format is for powershell scripts, so the scripts can check for state change in the relating values, in order, for the scripts to communicate with each other, thus producing multi-panel input/output...
1) the primary script/window ".\scripts\window1.ps1" should be the engine window, and have printed output for confirmations of each significant action performed by the ".\scripts\window1.ps1" script, to show what is going on, its config file should have all the required keys for the script, and when it has nothing to do, it should listen for communication from the user in the key "human_input" in the  config ".\scripts\config2.psd1" file, that upon being updated must be sent to the model via correct, prompt (".\prompts\converse.txt") and syntax and command, and then when there is a response, have the response sent back to the key "model_output" in the  config ".\data\config2.psd1" file, that will in turn be picked up upon by ".\scripts\window2.ps1".
2) the secondary script/window ".\scripts\window2.ps1" is a chat display, showing the values of the keys, human_input and model_output, showing the user's last input and the model's last output, with a prompt at the bottom "Enter your message: " for user input, that is immediately saved to "human_input" in ".\data\config2.psd1", and displayed in ".\scripts\window2.ps1", and then detected as updated by ".\scripts\window2.ps1", and sent to the model through the appropriate processes. 



INSTRUCTION:
what I now require is, for you to produce any required research upon code you are unsure of to, correctly and completely, implement, as much as you can of, what is outstanding into the scripts below, from what is outlined above. If you search for information, do not list sites, instead visit multiple sites selectively, and note critical information. 
 


RESOURCE:
Here is ".\scripts\window2.psd1"...



# window1.ps1

# Initialize Script
$scriptPath = Split-Path -Parent $MyInvocation.MyCommand.Definition
$modelsPath = "$scriptPath\models"
$config1Path = "$scriptPath\data\config1.psd1"
$config2Path = "$scriptPath\data\config2.psd1"
$envPath = "$scriptPath\.ENV"

# Load Environment Variables
$env = @{}
Get-Content $envPath | ForEach-Object {
    if ($_ -notmatch "^\*") {
        $line = $_ -split "#", 2 | Select-Object -First 1
        $keyValue = $line -split "=", 2
        if ($keyValue.Count -eq 2) {
            $key = $keyValue[0].Trim()
            $value = $keyValue[1].Trim()
            $env[$key] = $value
        }
    }
}

# Determine Processing Type and Executable Path
$processing = $env["processing"]
if ($processing -eq "avx2") {
    $llamaCppPath = "$scriptPath\llama\avx2"
    $coreMultiplier = 0.8
    $totalCores = 24
} elseif ($processing -eq "clblas") {
    $llamaCppPath = "$scriptPath\llama\clblas"
    $coreMultiplier = 0.8
    $totalCores = 2048
} else {
    Write-Host "Invalid processing type in .ENV. Exiting."
    exit
}

# Load Config1
if (Test-Path $config1Path) {
    $config1 = Import-PowerShellDataFile -Path $config1Path
} else {
    # Initialize config1 with default values from .ENV
    $config1 = @{
        rp_location = $env["rp_location"]
        human_name = $env["human_name"]
        model_name = $env["model_name"]
        model_role = $env["model_role"]
    }
    $config1 | Out-File -FilePath $config1Path
}

# Load Config2
if (Test-Path $config2Path) {
    $config2 = Import-PowerShellDataFile -Path $config2Path
} else {
    # Initialize config2 with default values
    $config2 = @{
        human_input = ""
        model_output = ""
    }
    $config2 | Out-File -FilePath $config2Path
}

# Function to Update Config
function Update-Config {
    param (
        [string]$filePath,
        [string]$key,
        [string]$value
    )
    $config = Import-PowerShellDataFile -Path $filePath
    $config[$key] = $value
    $config | Out-File -FilePath $filePath
}

# Check for Executable
$exePath = "$llamaCppPath\main.exe"
if (Test-Path $exePath) {
    Write-Host "main.exe found at $exePath."
} else {
    Write-Host "main.exe not found at $exePath. Exiting."
    exit
}

# Check for Executable
if (Test-Path "$llamaCppPath\main.exe") {
    Write-Host "main.exe found."
} else {
    Write-Host "main.exe not found. Exiting."
    exit
}

# Calculate Optimal Threads
$optimalThreads = [math]::Ceiling($totalCores * $coreMultiplier)
Write-Host "Optimal threads calculated as $optimalThreads based on $processing settings."

# Placeholder for -ngl Value
$nglValue = "32"  # Placeholder. Adjust based on GPU capabilities.

# Select Model
$models = Get-ChildItem -Path $modelsPath -Filter "*.gguf"
if ($models.Count -eq 0) {
    Write-Host "No .gguf model files found. Exiting."
    exit
} elseif ($models.Count -eq 1) {
    $selectedModel = $models[0].FullName
} else {
    Write-Host "Multiple models found. Please select one:"
    $counter = 1
    $models | ForEach-Object {
        Write-Host "$counter. $($_.Name)"
        $counter++
    }
    $selection = Read-Host "Enter the number of the model you want to use"
    $selectedModel = $models[$selection - 1].FullName
}

# Determine Context Length based on model filename
$contextLength = 4096
if ($selectedModel -match "8k") {
    $contextLength = 8192
} elseif ($selectedModel -match "16k") {
    $contextLength = 16384
} elseif ($selectedModel -match "32k") {
    $contextLength = 32768
} elseif ($selectedModel -match "64k") {
    $contextLength = 65536
} elseif ($selectedModel -match "128k") {
    $contextLength = 131072
}

# Set Other Parameters
$temp = 0.66
$repeatPenalty = 1.1
$nValue = -1  # Placeholder for number of bits, using -1 as default

# Placeholder for -ngl Value
$nglValue = "32"  # This is a placeholder. Adjust based on GPU capabilities.

# Placeholder for -p Value
$pValue = "[INST] <<SYS>>\nYou are Llama2CppRobot, in the role of the Chatbot. Do your best to answer the user, but always tell the truth. Your response should be in a maximum of two sentences, try to provide only the required output.\n<</SYS>>\n**instruction**[/INST]"

# Load Prompts
$prompts = Get-Content "$scriptPath\prompts\converse.txt" -Raw | ConvertFrom-StringData

# Process Prompts
$systemPrompt = $prompts["SYSTEM"] -replace "\{model_name\}", $config1["model_name"] -replace "\{model_role\}", $config1["model_role"]
$instructionPrompt = $prompts["INSTRUCTION"] -replace "\{human_name\}", $config1["human_name"] -replace "\{rp_location\}", $config1["rp_location"] -replace "\{model_name\}", $config1["model_name"] -replace "\{human_current\}", $config2["human_input"]

# Combine Prompts
$finalPrompt = "[INST] <<SYS>>`n$systemPrompt`n<</SYS>>`n$instructionPrompt[/INST]"

# TODO: Send the finalPrompt to the model and get the model_output

# Execute Command
$output = & "$llamaCppPath\main.exe" -t $optimalThreads -ngl $nglValue -m $selectedModel --color -c $contextLength --temp $temp --repeat_penalty $repeatPenalty -n $nValue -p $finalPrompt 2>&1


# Main Loop to Listen for Changes in human_input
while ($true) {
    # Refresh the config2 to get the latest human_input
    $config2 = Import-PowerShellDataFile -Path $config2Path

    if ($config2.human_input -ne "") {
        # Process the human_input and get the model_output
        $output = & "$llamaCppPath\main.exe" -t $optimalThreads -ngl $nglValue -m $selectedModel --color -c $contextLength --temp $temp --repeat_penalty $repeatPenalty -n $nValue -p $finalPrompt 2>&1

        # Update model_output in config2
        Update-Config -filePath $config2Path -key "model_output" -value $output

        # Clear human_input in config2
        Update-Config -filePath $config2Path -key "human_input" -value ""
    }

    # Wait before next iteration
    Start-Sleep -Seconds 1
}


RESOURCE:
update the script, then print the complete script.


# window2.ps1

# Initialize Script
$scriptPath = Split-Path -Parent $MyInvocation.MyCommand.Definition
$configPath = "$scriptPath\data\config2.psd1"  # Updated path
$promptsPath = "$scriptPath\prompts\converse.txt"

# Load Config
if (Test-Path $configPath) {
    $config = Import-PowerShellDataFile -Path $configPath
} else {
    # Initialize config with default values
    $config = @{
        human_input = ""
        model_output = ""
    }
    $config | Out-File -FilePath $configPath
}

# Function to Update Config
function Update-Config {
    param (
        [string]$key,
        [string]$value
    )
    $config[$key] = $value
    $config | Out-File -FilePath $configPath
}

# Set Console Window Title
$host.ui.RawUI.WindowTitle = "Llama2CppRobot - Window 2"

# Resize Console Window to 1/4 of screen width
Add-Type -AssemblyName System.Windows.Forms
$screenWidth = [System.Windows.Forms.Screen]::PrimaryScreen.Bounds.Width
$consoleWidth = [math]::Round($screenWidth / 4)
$host.UI.RawUI.BufferSize = New-Object Management.Automation.Host.Size ($consoleWidth, 50)
$host.UI.RawUI.WindowSize = New-Object Management.Automation.Host.Size ($consoleWidth, 50)

# Main Loop
while ($true) {
    # Clear the console
    Clear-Host

    
    # Initialize different types of separators
    $width = $host.UI.RawUI.WindowSize.Width

    # Generate separator line
    $separator1 = "-" * $width
    $separator2 = "-" * ($width / 2)
    $separator2 = $separator2 -replace "-", "-="
    $separator3 = "=" * $width

    # Display Chat
	Write-Host $separator3
    Write-Host " CHAT INTERFACE"
    Write-Host $separator3
	Write-Host $separator2
    Write-Host " Human Input"
    Write-Host $separator1
    Write-Host $($config.human_input)
    Write-Host $separator2
    Write-Host $separator2
    Write-Host " Model Output"
    Write-Host $separator1
    Write-Host $($config.model_output)
    Write-Host $separator2

    # User Input
    $userInput = Read-Host "Enter your message"
    Update-Config -key "human_input" -value $userInput

    # Refresh the config to get the latest model_output
    $config = Import-PowerShellDataFile -Path $configPath

    # Wait before next iteration
    Start-Sleep -Seconds 1
}



RESOURCE:
HEre is "config1.psd1"...

(empty)



RESOURCE:
HEre is "config2.psd1"...


Name                           Value                                                                                        
----                           -----                                                                                        
model_output                                                                                                                
human_input                                                                                                                 
